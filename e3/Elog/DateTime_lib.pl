######################################################################
#	DateTime_lib.pl
#	Библиотека работы с датами и временем
#
#	6 марта 2003 года					ООО "ЛЭНК"
######################################################################


######################################################################
#	Date
#	Класс функций работы с датами
######################################################################

package Date;

######################################################################
#	FromJulian
#	Определение даты Грегорианского календаря по юлианскому номеру
#	дня.
#	Вызов:
#		Date->FromJulian (JDay)
#	Параметры:
#		JDay - юлианский номер дня.
#	Возвращает массив параметров:
#		Month	  - номер месяца (1 - 12);
#		Day	  - число в месяце;
#		Year	  - год;
#		WeekDay - номер дня недели (0 - воскресенье, 6 - суббота).
######################################################################

sub FromJulian {
   shift;							# имя класса пропустить
   my $JulianDay = shift;				# юлианский номер дня
   my $WeekDay = ($JulianDay + 1) % 7;		# номер дня в неделе
   $JulianDay -= 1721119;
   my $Year = int (($JulianDay * 4 - 1) / 146097);
   $JulianDay = $JulianDay * 4 - 1 - $Year * 146097;
   my $Day = int ($JulianDay / 4);
   $JulianDay = int (($Day * 4 + 3) / 1461);
   $Day = $Day * 4 + 3 - $JulianDay * 1461;
   $Day = int (($Day + 4) / 4);
   my $Month = int (($Day * 5 - 3) / 153);
   $Day = $Day * 5 - 3 - $Month * 153;
   $Day = int (($Day + 5) / 5);
   $Year = $Year * 100 + $JulianDay;
   if ($Month < 10) {
	$Month += 3;
   } else {
	$Month -= 9;
	++$Year;
   }
   return ($Month, $Day, $Year, $WeekDay);	# вернуть результат
}

######################################################################
#	ToJulian
#	Определение юлианского номера дня по грегорианской дате.
#	Вызов:
#		Date->ToJulian (Month, Day, Year)
#	Параметры:
#		Month - номер месяца (1 - 12);
#		Day   - число;
#		Year  - год.
#	Возвращает номер для по юлианскому календарю.
######################################################################

sub ToJulian {
   shift;							# пропустить имя класса
   my $Month = shift;					# месяц
   my $Day = shift;					# число
   my $Year = shift;					# год
   if ($Month > 2) {
	$Month -= 3;
   } else {
	$Month += 9;
	--$Year;
   }
   my $C = int ($Year / 100);
   return int (($C * 146097) / 4) + int ((($Year - ($C * 100)) * 1461) / 4) +
     int (($Month * 153 + 2) / 5) + $Day + 1721119;	# вернуть результат
}

######################################################################
#	MonthName
#	Определение наименования месяца.
#	Вызов:
#		Date->MonthName (Month[, Limit[, Names]])
#	Параметры:
#		Month - номер месяца (1 - 12);
#		Limit - ограничение на число символов в возвращаемой
#			  строке (0 или не задано - нет ограничения);
#		Names - ссылка на массив имен (если опущена,
#			  используются английские наименования).
#	Возвращает символьную строку - наименование месяца.
######################################################################

sub MonthName {
   shift;							# пропустить имя класса
   my $Month = shift () + 0;				# номер месяца
   my $Limit = shift () + 0;				# ограничение
   my $Names = shift;					# ссылка на массив имен
   $Names = ["January", "February", "March", "April", "May", "June", "July", "August",
     "September", "October", "November", "December"] if (ref ($Names) ne "ARRAY");	# массив по умолчанию
   $Month = $Names->[$Month - 1];			# полное наименование месяца
   $Month = substr ($Month, 0, $Limit) if (defined ($Month) && $Limit);	# выделить подстроку
   return $Month;						# вернуть результат
}

######################################################################
#	WeekDayName
#	Определение наименования дня недели
#	Вызов:
#		Date->WeekDayName (WeekDay[, Limit[, Names]])
#	Параметры:
#		WeekDay - номер дня недели (0 - воскресенье, 6 - суббота);
#		Limit	  - ограничение на число символов в возвращаемой
#			    строке (0 или не задано - нет ограничения);
#		Names	  - ссылка на массив имен (если опущена,
#			    используются английские наименования).
#	Возвращает символьную строку - наименование дня недели.
######################################################################

sub WeekDayName {
   shift;							# пропустить имя класса
   my $WeekDay = shift () + 0;			# номер дня недели
   my $Limit = shift () + 0;				# ограничение
   my $Names = shift;					# ссылка на массив имен
   $Names = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Satturday"]
     if (ref ($Names) ne "ARRAY");			# массив по умолчанию
   $WeekDay = $Names->[$WeekDay];			# полное наименование дня недели
   $WeekDay = substr ($WeekDay, 0, $Limit) if (defined ($WeekDay) && $Limit);	# выделить подстроку
   return $WeekDay;					# вернуть результат
}

######################################################################


######################################################################
#	Time
#	Класс функций работы со временем
######################################################################

package Time;

######################################################################
#	ToAMPM
#	Преобразование времени к 12-часовому формату.
#	Вызов:
#		Time->ToAMPM (Hour)
#	Параметры:
#		Hour - час дня в 24-часовом формате.
#	Возвращает массив значений:
#		Hour - час дня в 12-часовом формате;
#		AMPM - признак половины дня:
#		       0 - до полудня (AM);
#		       1 - после полудня (PM).
######################################################################

sub ToAMPM {
   shift;							# пропустить имя класса
   my $Hour = shift;					# час дня
   my $AMPM = 0;						# предположим, что время до полудня
   if ($Hour >= 12) {					# время послеполуденное
	$AMPM = 1;						# отметить
	$Hour -= 12;					# корректировать время
   }
   $Hour = 12 if (!$Hour);				# ноля часов нет
   return ($Hour, $AMPM);				# вернуть результат
}

######################################################################
#	FromAMPM
#	Преобразование времени из 12-часового формата в 24-часовой.
#	Вызов:
#		Time->FromAMPM (Hour, AMPM)
#	Параметры:
#		Hour - час дня в 12-часовом формате;
#		AMPM - признак половины дня:
#		       0 - до полудня (AM);
#		       1 - после полудня (PM).
#	Возвращает час дня в 24-часовом формате.
######################################################################

sub FromAMPM {
   shift;							# пропустить имя класса
   my $Hour = shift;					# час дня
   my $AMPM = shift;					# признак половины дня
   $Hour = 0 if ($Hour == 12);			# ноль часов
   $Hour += 12 if ($AMPM);				# время после полудня
   return $Hour;						# вернуть результат
}

######################################################################
#	SystemTimeOffset
#	Определение текущего системного смещения часового пояса относи-
#  тельно Гринвичского.
#	Вызов:
#		Time->SystemTimeOffset ()
#	Параметры вызова отсутствуют.
#	Возвращает вычисленное по системным настройкам смещение часового
#  пояса относительно Гринвичского.
######################################################################

sub SystemTimeOffset {
   my $Offset = 0;					# начать с Гринвича
   my $CTime = time ();					# текущее время
   my $GMTime = join (" ", reverse ((gmtime ($CTime))[2..5]));	# по Гринвичу
   my $LcTime = join (" ", reverse ((localtime ($CTime))[2..5]));	# локальное
   my $OffsetStep = ($LcTime cmp $GMTime);	# направление движения
   while ($LcTime ne $GMTime) {			# до совпадения
	return 0 if (abs ($Offset) > 12);		# определить не удается - пусть будет Гринвич
	$Offset += $OffsetStep;				# подправить смещение
	$GMTime = join (" ", reverse ((gmtime ($CTime + $Self->{"timezone"} * 3600))[2..5]));	# время с поправкой
   }
   return $Offset;					# вернуть вычисленное значение
}

######################################################################


######################################################################
#	DateTime
#	Класс временных штампов и операций над ними.
######################################################################

package DateTime;

######################################################################
#	Now
#	Определение текущего момента времени с учетом часового пояса.
#	Вызов:
#		DateTime->Now ([Offset])
#		Object->Now ([Offset])
#	Параметры:
#		Offset - смещение часового пояса относительно
#			   Гринвичского (в часах).
#	Возвращает ссылку на новый или исходный объект типа DateTime.
######################################################################

sub Now {
   my $Self = shift;					# имя класса или ссылка на объект
   my $Offset = shift () + 0;				# смещение часового пояса
   if (ref ($Self) eq "") {				# вызван метод класса
	my $New = {};					# заготовка объекта
	$Self = bless ($New, $Self);			# связать с классом и переприсвоить
   }
   ($Self->{"sec"}, $Self->{"min"}, $Self->{"hour"}, $Self->{"day"}, $Self->{"month"},
     $Self->{"year"}, $Self->{"wday"}, undef, undef) = gmtime (time () + $Offset * 3600);	# разобрать текущее время
   ++$Self->{"month"};					# подправить месяц
   $Self->{"year"} += 1900;				# и год
   return $Self;						# вернуть ссылку
}

######################################################################
#	ToInternalString
#	Преобразует дату-время в строку "внутреннего" формата.
#	Вызов:
#		Object->ToInternalString ()
#	Возвращает строку в формате YYYYMMDDHHMMSS.
######################################################################

sub ToInternalString {
   my $Self = shift;					# ссылка на объект
   return sprintf ("%04d%02d%02d%02d%02d%02d", $Self->{"year"}, $Self->{"month"},
     $Self->{"day"}, $Self->{"hour"}, $Self->{"min"}, $Self->{"sec"});	# сформировать строку
}

######################################################################
#	FromInternalString
#	Формирует объект типа DateTime на основе строки "внутреннего"
#	формата.
#	Вызов:
#		DateTime->FromInternalString (String)
#		Object->FromInternalString (String)
#	Параметры:
#		String - строка формата YYYYMMDDHHMMSS.
#	Возвращает ссылку на новый или исходный объект типа DateTime.
######################################################################

sub FromInternalString {
   my $Self = shift;					# имя класса или ссылка на объект
   my $String = shift;					# строка во внутреннем формате
   return $Self->Create (substr ($String, 0, 4), substr ($String, 4, 2),
     substr ($String, 6, 2), substr ($String, 8, 2), substr ($String, 10, 2),
     substr ($String, 12, 2));			# сформировать заново
}

######################################################################
#	Copy
#	Создает копию объекта DateTime.
#	Вызов:
#		Object->Copy ()
#	Возвращает ссылку на объект-копию.
######################################################################

sub Copy {
   my $Self = shift;					# ссылка на объект
   return DateTime->Create ($Self->{"year"}, $Self->{"month"}, $Self->{"day"},
     $Self->{"hour"}, $Self->{"min"}, $Self->{"sec"});	# создать объект-копию
}

######################################################################
#	Create
#	Конструирует объект типа DateTime на основе раздельно заданных
#	элементов.
#	Вызов:
#		DateTime->Create (Year, Month, Day, Hour, Min, Sec)
#		Object->Create (Year, Month, Day, Hour, Min, Sec)
#	Параметры:
#		Year  - год;
#		Month - месяц (1 - 12);
#		Day   - число;
#		Hour  - час;
#		Min   - минута;
#		Sec   - секунда.
#	Возвращает ссылку на новый или исходный объект типа DateTime.
######################################################################

sub Create {
   my $Self = shift;					# имя класса или ссылка на объект
   my $Year = shift;					# год
   my $Month = shift;					# месяц
   my $Day = shift;					# число
   my $Hour = shift;					# час
   my $Min = shift;					# минута
   my $Sec = shift;					# секунда
   $Self = DateTime->Now () if (ref ($Self) eq "");	# вызван метод класса
   $Year = $Self->{"year"}
     if (!defined ($Year) || ($Year !~ m/^\d+$/) || ($Year < 100) || ($Year > 9999));	# подменить
   $Month = $Self->{"month"}
     if (!defined ($Month) || ($Month !~ m/^\d+$/) || ($Month < 1) || ($Month > 12));
   $Day = $Self->{"day"}
     if (!defined ($Day) || ($Day !~ m/^\d+$/) || ($Day < 1) || ($Day > 31));
   $Hour = $Self->{"hour"}
     if (!defined ($Hour) || ($Hour !~ m/^\d+$/) || ($Hour < 0) || ($Hour > 23));
   $Min = $Self->{"min"} 
     if (!defined ($Min) || ($Min !~ m/^\d+$/) || ($Min < 0) || ($Min > 59));
   $Sec = $Self->{"sec"}
     if (!defined ($Sec) || ($Sec !~ m/^\d+$/) || ($Sec < 0) || ($Sec > 59));
   my $MaxDay = (31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)[$Self->{"month"} - 1];	# максимальное число дней в месяце
   if ($MaxDay == 29) {					# февраль
	$MaxDay = 28 if (($Year % 4) || (!($Year % 100) && ($Year % 400)));	# невисокосный год
   }
   $Day = $MaxDay if ($Day > $MaxDay);		# подправить число
   $Self->{"year"} = $Year + 0;			# заполнить
   $Self->{"month"} = $Month + 0;
   $Self->{"day"} = $Day + 0;
   $Self->{"hour"} = $Hour + 0;
   $Self->{"min"} = $Min + 0;
   $Self->{"sec"} = $Sec + 0;
   $Self->{"wday"} = undef;				# день недели неизвестен
   return $Self;						# вернуть ссылку
}

######################################################################
#	Year
#	Вызов:
#		Object->Year ()
#	Возвращает год.
######################################################################

sub Year { return $_[0]->{"year"}; }

######################################################################
#	Month
#	Вызов:
#		Object->Month ()
#	Возвращает месяц.
######################################################################

sub Month { return $_[0]->{"month"}; }

######################################################################
#	Day
#	Вызов:
#		Object->Day ()
#	Возвращает число.
######################################################################

sub Day { return $_[0]->{"day"}; }

######################################################################
#	Hour
#	Вызов:
#		Object->Hour ()
#	Возвращает час.
######################################################################

sub Hour { return $_[0]->{"hour"}; }

######################################################################
#	Minute
#	Вызов:
#		Object->Minute ()
#	Возвращает минуту.
######################################################################

sub Minute { return $_[0]->{"min"}; }

######################################################################
#	Second
#	Вызов:
#		Object->Second ()
#	Возвращает секунду.
######################################################################

sub Second { return $_[0]->{"sec"}; }

######################################################################
#	WeekDay
#	Вызов:
#		Object->WeekDay ()
#	Возвращает день недели.
######################################################################

sub WeekDay {
   my $Self = shift;					# ссылка на объект
   (undef, undef, undef, $Self->{"wday"}) =
     Date->FromJulian (Date->ToJulian ($Self->{"month"}, $Self->{"day"}, $Self->{"year"}))
     if (!defined ($Self->{"wday"}));		# определить день недели
   return $Self->{"wday"};				# вернуть
}

######################################################################
#	GoDay
#	Переход на заданное число дней вперед или назад.
#	Вызов:
#		Object->GoDay (Days)
#	Параметры:
#		Days - число дней для перехода (отрицательное - назад).
#	Время не изменяется.
#	Возвращает ссылку на объект.
######################################################################

sub GoDay {
   my $Self = shift;					# ссылка на объект
   my $Days = int (shift);				# число дней
   ($Self->{"month"}, $Self->{"day"}, $Self->{"year"}, $Self->{"wday"}) =
     Date->FromJulian (Date->ToJulian ($Self->{"month"}, $Self->{"day"}, $Self->{"year"}) +
     $Days);						# новая дата
   return $Self;
}

######################################################################
#	GoMonth
#	Переход на заданное число месяцев вперед или назад.
#	Вызов:
#		Object->GoMonth (Months)
#	Параметры:
#		Months - число месяцев для перехода (отрицательное - назад).
#	Время не изменяется. Число может быть скорректировано для
#	предотвращения выхода за пределы месяца.
#	Возвращает ссылку на объект.
######################################################################

sub GoMonth {
   my $Self = shift;					# ссылка на объект
   my $NewMonth = $Self->{"month"} - 1 + int (shift);	# новый месяц
   my $NewYear = $Self->{"year"} + int ($NewMonth / 12);	# новый год
   my $YearMonth = $NewMonth % 12;			# месяц в пределах года
   --$NewYear if ($YearMonth && ($NewMonth < 0));	# поправка на обратный переход
   $Self->{"year"} = $NewYear;			# установить
   $Self->{"month"} = $YearMonth + 1;
   my $MaxDay = (31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)[$YearMonth];	# максимальное число дней в месяце
   if ($MaxDay == 29) {					# февраль
	$MaxDay = 28 if (($NewYear % 4) || (!($NewYear % 100) && ($NewYear % 400)));	# невисокосный год
   }
   $Self->{"day"} = $MaxDay if ($Self->{"day"} > $MaxDay);	# подправить число
   $Self->{"wday"} = undef;				# день недели неизвестен
   return $Self;						# вернуть ссылку
}

######################################################################
#	MonthName
#	Определение наименования месяца.
#	Вызов:
#		Object->MonthName ([Limit[, Names]])
#	Параметры:
#		Limit - ограничение на число символов в возвращаемой
#			  строке (0 или не задано - нет ограничения);
#		Names - ссылка на массив имен (если опущена,
#			  используются английские наименования).
#	Возвращает символьную строку - наименование месяца.
######################################################################

sub MonthName { return Date->MonthName ($_[0]->{"month"}, $_[1], $_[2]); }

######################################################################
#	WeekDayName
#	Определение наименования дня недели
#	Вызов:
#		Object->WeekDayName ([Limit[, Names]])
#	Параметры:
#		Limit	- ограничение на число символов в возвращаемой
#			  строке (0 или не задано - нет ограничения);
#		Names	- ссылка на массив имен (если опущена,
#			  используются английские наименования).
#	Возвращает символьную строку - наименование дня недели.
######################################################################

sub WeekDayName { return Date->WeekDayName ($_[0]->WeekDay (), $_[1], $_[2]); }

######################################################################
#	MidNight
#	Сброс времени на полночь.
#	Вызов:
#		Object->MidNight ()
#	Возвращает ссылку на объект.
######################################################################

sub MidNight {
   my $Self = shift;					# ссылка на объект
   $Self->{"hour"} = $Self->{"min"} = $Self->{"sec"} = 0;	# сбросить время в ноль
   return $Self;						# вернуть ссылку
}

######################################################################
#	Bewtween
#	Проверяет нахождение временного штампа в заданных границах.
#	Вызов:
#		Object->Between (B1, B2)
#	Параметры:
#		B1, B2 - ссылки на объекты DateTime, задающие границы.
#	Возвращает нулевое значение, если штамп не попадает в нужные
#	границы, и ненулевое в противном случае.
######################################################################

sub Between {
   my $Self = shift;					# ссылка на объект
   my $Bound1 = shift;					# первая граница
   my $Bound2 = shift;					# вторая граница
   ($Bound1, $Bound2) = sort ($Bound1->ToInternalString (), $Bound2->ToInternalString ());	# правильный порядок границ во внутреннем формате
   $Self = $Self->ToInternalString ();		# преобразовать во внутренний формат
   return (($Self ge $Bound1) && ($Self le $Bound2)) + 0;	# вернуть результат
}

######################################################################
#	Format
#	Преобразование временного штампа в текстовую строку по заданному
#	формату.
#	Вызов:
#		Object->Format (String[, Months[, WDays]])
#	Параметры:
#		String - строка форматного представления;
#		Months - ссылка на массив имен месяцев (если опущена,
#			   используются английские наименования);
#		WDays  - ссылка на массив имен дней недели (если опущена,
#			   используются английские наименования).
#	Преобразование происходит аналогично стандартным форматным
#	преобразованиям. Специальные поля имеют вид \a[n]X, где
#	\a - специальный префикс, непечатный символ;
#	n  - необязательное задание размера поля;
#	X  - тип поля:
#	     Y - год. Поле размером 2 либо 4 символа, по умолчанию 2;
#	     C - то же, что 4Y. Указание размера игнорируется;
#	     M - цифровое представление месяца. Размер поля может быть
#		   только 2. Если не указан, используется переменный размер;
#	     T - текстовое представление месяца. Размер поля любой, по
#		   умолчанию используется наименование полностью;
#	     D - цифровое представление числа. Размер поля может быть
#		   только 2. Если не указан, используется переменный размер;
#	     W - текстовое представление дня недели. Размер поля любой, по
#		   умолчанию используется наименование полностью;
#	     H - цифровое представление часа в 24-часовом формате. Размер
#		   поля может быть только 2. Если не указан, используется
#		   переменный размер;
#	     A - цифровое представление часа в 12-часовом формате. Размер
#		   поля может быть только 2. Если не указан, используется
#		   переменный размер;
#	     I - цифровое представление минуты. Размер поля может быть
#		   только 2. Если не указан, используется переменный размер;
#	     S - цифровое представление секунды. Размер поля может быть
#		   только 2. Если не указан, используется переменный размер;
#	     P - признак времени до/после полудня для 12-часового формата
#		   времени. Отображается только в виде AM или PM.
#	Возвращает отформатированную строку.
######################################################################

sub Format {
   my $Self = shift;					# ссылка на объект
   my $Format = shift;					# строка формата
   my $MonthNames = shift;				# ссылка на массив имен месяцев
   my $WeekDayNames = shift;				# ссылка на массив имен дней недели
   my $Result = "";					# заготовка результата
   my ($H12, $AMPM) = (undef, undef);		# параметры 12-часового формата
   while ($Format =~ m/\a(\d*)([YCMTDWHAISP])/) {	# пока обнаруживаются форматные переменные
	$Result .= $`;					# передать неспециальную часть в результат
	$Format = $';					# вырезать обработанный фрагмент
	my $FieldSize = $1;				# размер поля
	my $FieldType = $2;				# тип поля
	($H12, $AMPM) = Time->ToAMPM ($Self->{"hour"})
	  if (($FieldType =~ m/[AP]/) && !defined ($H12));	# требуется 12-часовой формат
	if ($FieldType eq "P") {			# признак половины дня
	   $Result .= ($AMPM) ? "PM" : "AM";	# подставить
	} elsif ($FieldType eq "T") {			# месяц текстом
	   $Result .= Date->MonthName ($Self->{"month"}, $FieldSize, $MonthNames);	# подставить
	} elsif ($FieldType eq "W") {			# день недели текстом
	   $Result .= Date->WeekDayName ($Self->WeekDay (), $FieldSize, $WeekDayNames);	# подставить
	} else {
	   my $Temp = undef;				# временная переменная
	   if ($FieldType =~ m/[YC]/) {		# год
		$Temp = $Self->{"year"};		# преобразуемое значение
		if ($FieldType eq "Y") {		# с указанием размера
		   if ($FieldSize != 4) {		# не в четыре цифры
			$FieldSize = 2;			# тогда в две
			$Temp %= 100;			# причем последние
		   }
		} else {					# строго 4 цифры
		   $FieldSize = 4;
		}
	   } else {						# все остальное
		$FieldSize = 0 if ($FieldSize != 2);	# либо 2 символа, либо как получится
		if ($FieldType eq "M") {		# месяц
		   $Temp = $Self->{"month"};
		} elsif ($FieldType eq "D") {		# число
		   $Temp = $Self->{"day"};
		} elsif ($FieldType eq "H") {		# час
		   $Temp = $Self->{"hour"};
		} elsif ($FieldType eq "A") {		# час до/после полудня
		   $Temp = $H12;
		} elsif ($FieldType eq "I") {		# минута
		   $Temp = $Self->{"min"};
		} elsif ($FieldType eq "S") {		# секунда
		   $Temp = $Self->{"sec"};
		}
	   }
	   if (defined ($Temp)) {			# есть чего отображать
		$Temp += 0;					# произвольный размер
		$Temp = sprintf ("%0" . $FieldSize . "d", $Temp) if ($FieldSize);	# преобразовать по фиксированному размеру
		$Result .= $Temp;				# добавить в результат
	   }
	}
   }
   $Result .= $Format;					# хвост строки
   return $Result;					# вернуть результат
}

######################################################################
#	ToEmailDate
#	Преобразование в строку формата, принятого для маркировки
#	электронных писем.
#	Вызов:
#		Object->ToEmailDate ([Offset])
#	Параметры:
#		Offset - смещение часового пояса относительно Гринвича.
#	Возвращает строку вида Fri, 08 Sep 2000 17:44:00 +0400
######################################################################

sub ToEmailDate {
   my $Self = shift;					# ссылка на объект
   my $Offset = sprintf ("%+05d", int ((shift () + 0) * 100));	# отформатировать смещение
   return $Self->Format ("\a3W, \a2D \a3T \aC \a2H:\a2I:\a2S ") . $Offset;	# вернуть готовую строку
}

1;
